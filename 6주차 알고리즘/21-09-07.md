# 6주차 알고리즘 공부 (21-09-07)
## 기본 수학1 문제
### 분수 찿기
#### 문제 내용
무한히 큰 배열에 다음과 같이 분수들이 적혀있다.

![image](https://user-images.githubusercontent.com/80632806/132332871-962c37ce-4d33-4500-bc61-a811a48cc0ae.png)

이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.

X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.

#### 입력과 출력

입력 : 첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.
출력 : 첫째 줄에 분수를 출력한다.

![image](https://user-images.githubusercontent.com/80632806/132333112-55965b69-da9c-46f3-96d9-aa52cfea8632.png)

#### 문제 풀이 방법

이 문제는 이전의 벌집문제와 유사한 형식이라고 생각했다. 대각선을 기준으로 수열을 나누어서 풀어보려고 했는데, 문제는 입력한 수를 어떤 방식으로
찾아내어 출력을 해야되는 것인지에 대해서 많은 고민을 했다. 처음에는 수열의 마지막 수를 기준으로 해서 조건을 나눈 뒤 이를 반복문으로 돌려서 출력 값
만들려고 했는데, 이렇게 하니 입력 값을 찾아낼 수 가 없어서 최종적으로는 수열의 첫번째 수도 사용하여 반복문이 돌아 갈때마다 시작하는 수열의 수가 1씩
늘어나면서 입력 값과 같으면 반복문을 탈출하는 방식으로 해결했다.

#### 코드

```python
X = int(input())
fst = 1 #수열의 마지막 숫자
oly = 1 #수열의 첫 숫자
number = 2 # 수열의 마지막 숫자 증가량 / 분모,분자의 합
olyplus = 1 # 수열의 첫 숫자 증가량
deno = 0  #분모
numer = 0 #분자
check = True
while check == True :
    if X == 1 :  #첫번째 수면 바로 해제
        deno += 1
        numer += 1
        break
    elif X > fst : #입력받은 수가 수열보다 크면, 수열을 증가
        fst += number
        oly += olyplus
        number += 1
        olyplus += 1
    else :           
        if number % 2 == 1:      # 수열의 증가 값을 기준으로 조건을 구분
            for i in range(1, number) :
                deno = number - i   # 그림에 나와있는 분모,분자 증가값
                numer = i
                if X == oly-1+i :
                    check = False
                    break
        else :
            for i in range(1, number) :
                deno = i             # 그림에 나와있는 분모,분자 증가값
                numer = number - i
                if X == oly-1+i :
                    check = False
                    break
numer = str(numer)
deno = str(deno)
print(numer+'/'+deno)
```

****************************************************************************

### 나무에 올라가는 달팽이를 죽이고 싶다
#### 문제 내용

땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.

달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.

달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.

#### 입력과 출력

입력 : 첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)

출력 : 첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.

![image](https://user-images.githubusercontent.com/80632806/132484966-81e89650-678b-4413-8488-99f56b6b555b.png)

#### 문제 풀이 방식

염병할 달팽이가 왜 나무에 그렇게 올라가고 싶어 하는지 모르겠으나, 일단 이 문제를 보고 생각한 포인트는 다음과 같다.
1. 달팽이는 하루에 걸쳐서 올라가고 떨어지지만, 만약 올라갔을 때 정상에 도착한다면 내려오는 것을 생각할 필요가 없다.
2. 달팽이가 올라가고 내려오는 것을 반복문을 통해 구현하되 낮에 정상에 도착할 경우를 생각한다.

다음과 같은 포인트를 중점으로 문제를 풀어 보려고 했지만, 완성된 코드는 작은 값에서는 제대로 결과를 도출하지만, 값이 커지면 반복문에 의해서 많은 시간이 걸리게 되므로 해당 문제에서 요구하는 
제한 시간인 0.15초를 지키지 못하게 된다.

이를 통해, 해당 문제는 반복문이 아니라 일정한 공식에 의해서 씹팽이에게 필요한 날을 구해 줘야한다는 것을 알게 되었다.

여러가지 공식을 시험해 봤었는데, 결론적으로 나온 식은

A + (A-B)*n >= V -> n >= (V-A)/(A-B)  ///등차수열

로 나타났다. 즉 이를 만족하는 n의 최소 값이 씹팽이에게 필요한 날이 된다. 

이때, n이 소수점 단위로 나타나는데, 이는 추가적으로 하루가 더 필요하다는 뜻이므로, math를 이용해 올림으로 n을 정해줬다.
n이 정수로 나타났다면, A-B만으로도 결과에 도달했다는 뜻이므로 n을 그대로 출력한다.
하지만 소수 점의 경우 마지막에 A만큼의 거리가 남았으므로 1을 더했다.
(마지막 부분은 뭔가 애매함)

이를 통해서 결과를 도출할 수 있었다. 해당 문제에 3일을 쏟은게 ㅈ같을 정도로 간단한 문제였다. 고맙다 핑핑아!

#### 코드
```python
import math
A, B, V = map(int, input().split())
daygo = (V-A)/(A-B)
strdaygo = str(daygo)
if strdaygo.isdecimal() != True :
    daygo = math.ceil(daygo) + 1
print(daygo)
```

